import os
import pandas as pd
import logging
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from datetime import datetime
import time
import uuid
import re

# ConfiguraÃ§Ã£o de logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')


def esperar_elemento(driver, xpath, timeout=10):
    return WebDriverWait(driver, timeout).until(
        EC.presence_of_element_located((By.XPATH, xpath))
    )


def conectar_navegador_existente():
    options = webdriver.ChromeOptions()
    options.debugger_address = "localhost:9222"
    try:
        driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options)
        logging.info("Conectado ao navegador existente!")
        print("âœ… Conectado ao navegador existente!")
        return driver
    except Exception as erro:
        logging.error(f"Erro ao conectar ao navegador: {erro}")
        print(f"âŒ Erro ao conectar ao navegador: {erro}")
        exit()


def ler_planilha(arquivo):
    """LÃª a planilha de entrada mantendo todos os dados originais da aba Document_CH321"""
    try:
        df = pd.read_excel(arquivo, sheet_name='Document_CH321')
        if 'NÂ° ConvÃªnio' not in df.columns:
            raise ValueError("Coluna 'NÂ° ConvÃªnio' nÃ£o encontrada na planilha.")
        logging.info("Planilha lida com sucesso! Mantendo todas as colunas originais.")
        print("âœ… Planilha lida com sucesso! Mantendo todas as colunas originais.")
        return df
    except Exception as erro:
        logging.error(f"Erro ao ler planilha: {erro}")
        print(f"âŒ Erro ao ler planilha: {erro}")
        exit()


def obter_ultimo_indice_processado(arquivo_saida):
    """Verifica a planilha de saÃ­da e retorna o Ã­ndice do Ãºltimo instrumento processado. """
    try:
        if os.path.exists(arquivo_saida):
            df_saida = pd.read_excel(arquivo_saida, sheet_name='Document_CH321')
            # Encontra a Ãºltima linha com 'Data mais recente' ou 'MovimentaÃ§Ã£o' nÃ£o nula
            mask = df_saida['Data Mais Recente'].notna() |df_saida['MovimentaÃ§Ã£o'].notna()
            if mask.any():
                ultimo_indice = mask[mask].index[-1]
                logging.info(f"Ãšltimo instrumento processado encontrado no Ã­ndice: {ultimo_indice}" )
                print(f"âœ… Ãšltimo instrumento processado encontrado no Ã­ndice: {ultimo_indice}")
                return ultimo_indice
        return -1 # Retorna -1 se nÃ£o houver planilha ou instrumento processados
    except Exception as erro:
        logging.error(f"Erro ao verificar planilha de saÃ­da: {erro}")
        print(f"âŒ Erro ao verificar planilha de saÃ­da: {erro}")
        return -1




def criar_planilha_saida(arquivo_entrada, df, primeiro_instrumento=False):
    """Cria ou atualiza a planilha de saÃ­da com os dados originais mais as novas colunas"""
    try:
        pasta = os.path.dirname(arquivo_entrada)
        nome_base = os.path.basename(arquivo_entrada)

        if '.' in nome_base:
            nome_base = nome_base[:nome_base.rfind('.')]

        arquivo_saida = os.path.join(pasta, f"{nome_base}_COM_DATAS.xlsx")

        # Se for o primeiro instrumento, cria novo arquivo
        if primeiro_instrumento:
            contador = 1
            while os.path.exists(arquivo_saida):
                arquivo_saida = os.path.join(pasta, f"{nome_base}_COM_DATAS_{contador}.xlsx")
                contador += 1

            # Cria nova planilha com a aba Document_CH321
            with pd.ExcelWriter(arquivo_saida, engine='openpyxl') as writer:
                df.to_excel(writer, sheet_name='Document_CH321', index=False)
        else:
            # Atualiza o arquivo existente
            with pd.ExcelWriter(arquivo_saida, engine='openpyxl', mode='a', if_sheet_exists='replace') as writer:
                df.to_excel(writer, sheet_name='Document_CH321', index=False)

        logging.info(f"Planilha de saÃ­da {'criada' if primeiro_instrumento else 'atualizada'}: {arquivo_saida}")
        print(f"âœ… Planilha de saÃ­da {'criada' if primeiro_instrumento else 'atualizada'}: {arquivo_saida}")
        return arquivo_saida
    except Exception as e:
        logging.error(f"Erro ao {'criar' if primeiro_instrumento else 'atualizar'} planilha de saÃ­da: {e}")
        print(f"âŒ Erro ao {'criar' if primeiro_instrumento else 'atualizar'} planilha de saÃ­da: {e}")
        return None


def navegar_menu_principal(driver, instrumento):
    try:
        esperar_elemento(driver, "/html/body/div[1]/div[3]/div[1]/div[1]/div[1]/div[4]").click()
        esperar_elemento(driver, "/html[1]/body[1]/div[1]/div[3]/div[2]/div[1]/div[1]/ul[1]/li[6]/a[1]").click()
        campo_pesquisa = esperar_elemento(driver,
                                          "/html[1]/body[1]/div[3]/div[15]/div[3]/div[1]/div[1]/form[1]/table[1]/tbody[1]/tr[2]/td[2]/input[1]")
        campo_pesquisa.clear()
        campo_pesquisa.send_keys(instrumento)
        esperar_elemento(driver,
                         "/html[1]/body[1]/div[3]/div[15]/div[3]/div[1]/div[1]/form[1]/table[1]/tbody[1]/tr[2]/td[2]/span[1]/input[1]").click()
        time.sleep(1)
        esperar_elemento(driver,
                         "/html[1]/body[1]/div[3]/div[15]/div[3]/div[3]/table[1]/tbody[1]/tr[1]/td[1]/div[1]/a[1]").click()
        return True
    except:
        print(f"âš ï¸ Instrumento {instrumento} nÃ£o encontrado.")
        return False


def acessar_aba_movimentacao_financeira(driver):
    """Acessa a aba de MovimentaÃ§Ã£o Financeira com mÃºltiplos caminhos alternativos"""
    try:
        # Primeiro clique - Tenta dois caminhos diferentes para o menu principal
        try:
            # Tentativa 1: Caminho XPath original
            esperar_elemento(driver, "/html/body/div[3]/div[15]/div[1]/div/div[1]/a[6]/div/span/span").click()
        except Exception as e:
            # Tentativa 2: Novo JS Path como fallback
            driver.execute_script('document.querySelector("#div_-481524888 > span > span").click()')

        time.sleep(1)

        # Segundo clique - MovimentaÃ§Ã£o Financeira
        try:
            # Tentativa 1: ExecuÃ§Ã£o via JavaScript
            driver.execute_script('document.querySelector("#menu_link_-481524888_1304359359 > div > span").click()')
        except Exception as e:
            # Tentativa 2: Caminho XPath alternativo
            esperar_elemento(driver, "/html/body/div[3]/div[15]/div[1]/div/div[2]/a[26]/div/span/span").click()

        time.sleep(1)
        return True

    except Exception as erro:
        logging.error(f"Erro ao acessar aba MovimentaÃ§Ã£o Financeira: {erro}")
        print(f"âŒ Erro ao acessar aba MovimentaÃ§Ã£o Financeira: {erro}")
        return False


def coletar_data_recente(driver):
    """Coleta a data mais recente da tabela de movimentaÃ§Ã£o financeira"""
    try:
        tabela = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.XPATH, "/html/body/div[3]/div[16]/div[2]/form/table"))
        )

        rows = tabela.find_elements(By.TAG_NAME, "tr")
        datas = []

        for row in rows[1:]:  # Pular cabeÃ§alho se existir
            try:
                cells = row.find_elements(By.TAG_NAME, "td")
                if len(cells) >= 2:  # Verifica se hÃ¡ pelo menos 2 colunas
                    data_text = cells[1].text.strip()
                    if re.match(r"\d{2}/\d{2}/\d{4}", data_text):
                        data = datetime.strptime(data_text, "%d/%m/%Y")
                        datas.append(data)
            except:
                continue

        if datas:
            data_recente = max(datas).strftime("%d/%m/%Y")
            return data_recente, "SIM"  # Agora retorna apenas a data e "SIM"
        else:
            return None, "NÃƒO"  # Retorna None e "NÃƒO" quando nÃ£o hÃ¡ dados

    except:
        return None, "NÃƒO"  # Retorna None e "NÃƒO" quando nÃ£o encontra a tabela


def navegar_voltar_inicio(driver):
    """Navega de volta para a pÃ¡gina inicial entre cada proposta"""
    try:
        driver.get("https://discricionarias.transferegov.sistema.gov.br/voluntarias/Principal/Principal.do")
        time.sleep(2)  # Espera carregar a pÃ¡gina
        print("âœ… Voltou para a pÃ¡gina inicial com sucesso")
        return True
    except Exception as e:
        print(f"âŒ Erro ao voltar para pÃ¡gina inicial: {e}")
        return False


def main():
    # ConfiguraÃ§Ã£o inicial
    arquivo_entrada = r"C:\Users\diego.brito\Downloads\robov1\MovimentaÃ§Ã£o Financeira\20250506 - Parcerias em ExecuÃ§Ã£o com Desembolso Acumulado.xlsx"

    # Ler planilha mantendo todos os dados originais
    df = ler_planilha(arquivo_entrada)
    total_instrumentos = len(df)

    # Adicionar colunas novas
    df['Data Mais Recente'] = pd.NA
    df['MovimentaÃ§Ã£o'] = pd.NA

    # Determinar o nome da planilha de saÃ­da
    pasta = os.path.dirname(arquivo_entrada)
    nome_base = os.path.basename(arquivo_entrada).rsplit('.', 1)[0]
    arquivo_saida_base = os.path.join(pasta, f"{nome_base}_COM_DATAS.xlsx")

    # Verificar se a planilha de saÃ­da jÃ¡ existe e obter o Ãºltimo Ã­ndice processado
    ultimo_indice = -1
    arquivo_saida = arquivo_saida_base
    contador = 1
    while os.path.exists(arquivo_saida):
        ultimo_indice = obter_ultimo_indice_processado(arquivo_saida)
        if ultimo_indice >= 0:
            break
        arquivo_saida = os.path.join(pasta, f"{nome_base}_COM_DATAS_{contador}.xlsx")
        contador += 1

    # Se a planilha de saÃ­da existe, carregar os dados jÃ¡ processados
    if ultimo_indice >= 0:
        df_saida = pd.read_excel(arquivo_saida, sheet_name='Document_CH321')
        df.update(df_saida)  # Atualiza o DataFrame com os dados jÃ¡ processados
        print(f"âœ… Retomando a partir do Ã­ndice {ultimo_indice + 1}")

    driver = conectar_navegador_existente()
    arquivo_saida_criado = False
    tempos = []
    inicio_geral = time.time()

    try:
        for index, row in df.iterrows():
            if index <= ultimo_indice:
                continue  # Pula instrumentos jÃ¡ processados

            instrumento = str(int(row['NÂ° ConvÃªnio'])) if pd.notna(row['NÂ° ConvÃªnio']) else ""

            if pd.isna(row['NÂ° ConvÃªnio']):
                print(f"âš ï¸ CÃ©lula em branco no Ã­ndice {index}. Pulando para o prÃ³ximo.")
                continue

            inicio_instrumento = time.time()

            # CÃ¡lculo do progresso
            progresso = (index + 1) / total_instrumentos * 100
            restantes = total_instrumentos - (index + 1)

            print("\n" + "=" * 60)
            print(f"ðŸš€ PROCESSANDO INSTRUMENTO {index + 1}/{total_instrumentos}")
            print(f"ðŸ“Œ ConvÃªnio atual: {instrumento}")
            print(f"ðŸ“Š Progresso: {progresso:.1f}% concluÃ­do")
            print(f"ðŸ•‘ Instrumentos restantes: {restantes}")

            if tempos:
                tempo_medio = sum(tempos) / len(tempos)
                tempo_estimado = tempo_medio * restantes
                horas, rem = divmod(tempo_estimado, 3600)
                minutos, segundos = divmod(rem, 60)
                print(f"â± Tempo estimado restante: {int(horas):02d}h {int(minutos):02d}m {int(segundos):02d}s")

            print("=" * 60 + "\n")

            if navegar_menu_principal(driver, instrumento):
                if acessar_aba_movimentacao_financeira(driver):
                    data_recente, possui_data = coletar_data_recente(driver)
                else:
                    data_recente, possui_data = None, "NÃƒO"
            else:
                data_recente, possui_data = None, "NÃƒO"

            # Atualizar DataFrame
            df.at[index, 'Data Mais Recente'] = data_recente
            df.at[index, 'MovimentaÃ§Ã£o'] = possui_data

            # Calcular tempo deste instrumento
            tempo_instrumento = time.time() - inicio_instrumento
            tempos.append(tempo_instrumento)
            print(f"â³ Tempo deste instrumento: {tempo_instrumento:.1f} segundos")

            # Criar/atualizar planilha de saÃ­da
            if not arquivo_saida_criado:
                arquivo_saida = criar_planilha_saida(arquivo_entrada, df, primeiro_instrumento=True)
                arquivo_saida_criado = True
            else:
                arquivo_saida = criar_planilha_saida(arquivo_entrada, df, primeiro_instrumento=False)

            # Voltar para pÃ¡gina inicial antes do prÃ³ximo instrumento
            if index < total_instrumentos - 1:
                if not navegar_voltar_inicio(driver):
                    print("âš ï¸ NÃ£o conseguiu voltar para pÃ¡gina inicial, tentando recarregar...")
                    try:
                        driver.get("https://discricionarias.transferegov.sistema.gov.br/voluntarias/Principal/Principal.do")
                        time.sleep(3)
                    except Exception as e:
                        print(f"âŒ Falha ao recarregar pÃ¡gina inicial: {e}. Salvando progresso e encerrando...")
                        criar_planilha_saida(arquivo_entrada, df, primeiro_instrumento=False)
                        raise  # Re-levanta a exceÃ§Ã£o para encerrar

    except Exception as erro:
        logging.error(f"Erro durante o processamento: {erro}")
        print(f"âŒ Erro durante o processamento: {erro}")
        print(f"ðŸ“ Salvando progresso na planilha: {arquivo_saida}")
        criar_planilha_saida(arquivo_entrada, df, primeiro_instrumento=False)
        print("âš ï¸ Corrija o problema e reinicie o script. O processamento serÃ¡ retomado automaticamente.")
        driver.quit()
        exit()

    # CÃ¡lculo do tempo total
    tempo_total = time.time() - inicio_geral
    horas, rem = divmod(tempo_total, 3600)
    minutos, segundos = divmod(rem, 60)

    print("\n" + "=" * 60)
    print("âœ… PROCESSO CONCLUÃDO COM SUCESSO!")
    print(f"â± Tempo total: {int(horas):02d}h {int(minutos):02d}m {int(segundos):02d}s")
    print(f"ðŸ“ Arquivo gerado: {arquivo_saida}")
    print("=" * 60)

    driver.quit()

if __name__ == "__main__":
    main()